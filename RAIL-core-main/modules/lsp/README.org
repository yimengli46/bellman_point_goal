
* LSP: Learned Subgoal Planning

This module is devoted to the core Learned Subgoal Planning work and to providing a handful of functionality useful for computing frontiers and for subgoal-based planning.


** Organization

The =Planner= class provides a relatively simple API for updating an internal "state of the world" and computing which subgoal the planner recommends. The planner classes are most easily used in tandem with the =PlanningLoop= class also provided alongside the =lsp.planning= module. For example, the following code shows how to generate data using the =KnownSubgoalPlanner= class:

#+begin_src python
  known_planner = lsp.planners.KnownSubgoalPlanner(
      goal=goal, known_map=known_map, args=args,
      do_compute_weightings=True)

  planning_loop = lsp.planners.PlanningLoop(goal,
                                            known_map,
                                            simulator,
                                            unity_bridge,
                                            robot,
                                            args,
                                            verbose=True)

  for counter, step_data in enumerate(planning_loop):
      # Update the planner objects
      known_planner.update(
          {'image': step_data['image']},
          step_data['robot_grid'],
          step_data['subgoals'],
          step_data['robot_pose'],
          step_data['visibility_mask'])

      # Get and write the data
      subgoal_training_data = known_planner.get_subgoal_training_data()
      lsp.utils.data.write_training_data_to_pickle(
          subgoal_training_data,
          step_counter=known_planner.update_counter,
          args=known_planner.args)

      if not do_plan_with_naive:
          planning_loop.set_chosen_subgoal(
              known_planner.compute_selected_subgoal())
#+end_src

At every iteration, the =planning_loop= class yields the =step_data= dictionary, which contains the information needed to update the =known_planner=. The =known_planner= contains functionality to generate training data, with labels generated from the known map. At the end, the known planner can be optionally used to set the "chosen subgoal" of the =planning_loop=, which the =planning_loop= object will use to plan for the next step and will therefore follow the plan chosen by the known planner. If the chosen subgoal is not set, the =planning_loop= will simply plan using Dijkstra's algorithm (as if all unseen space were unoccupied).

More examples of how to use the =Planner= classes can be found in the =lsp.scripts= for data generation and evaluation and in =tests.test_lsp_evaluate=.
